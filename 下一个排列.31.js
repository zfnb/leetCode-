/**
思路
从低位挑一个数，往前换走一个小一点的数，实现变大
变大的幅度要尽量小

像 321 递减的，就没有下一个排列，
因为大的已经尽量往前排了，没法更大。
像 152432 ，我们希望它稍微变大。
从低位看，从右边挑一个数，往前换走一个小一点的数。
往右寻找第一个比右邻居小的数，让它和右边的数交换，从而变大。
找到 15 (2) 432 中间这个 2。
依然从右遍历，小于等于这个 2 的，跳过。
直到遇到第一个比它大的，15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2。
变大的幅度可以小一点，千位变大了，后三位尽量小。
后三位是递减的，进行翻转，变成 153 224 ，即 152432 的下一个排列。
 */
function nextPermutation(nums) {
    let i = nums.length - 2;  // 从倒数第二个，向左遍历
    // 寻找第一个小于右邻居的数(i<i+1)
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    // 到达这个位置说明已经找到了满足i<i+1的位置，或者整个数组没有满足的位置
    // 这个位置的i 右边的数字都是从大到小排列

    // 如果找到的这个位置，数组中存在
    if (i >= 0) {
        // 从最后一项，向左遍历
        let j = nums.length - 1;
         // 寻找第一个大于 nums[i] 的数，这两个位置交换位置，整个数字会增大
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]]; // 两数交换，实现变大
    }
    // 如果i=-1，说明是递减排列，如 321，则直接翻转为最小排列：123
    let l = i + 1;            // i 右边的数进行翻转，使得变大的幅度小一些
    let r = nums.length - 1;
    while (l < r) {
        [nums[l], nums[r]] = [nums[r], nums[l]];
        l++;
        r--;
    }
}